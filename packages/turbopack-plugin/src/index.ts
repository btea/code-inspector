import {
  CodeOptions,
  RecordInfo,
  startServer,
  getWebComponentCode,
  isDev,
} from 'code-inspector-core';
import path from 'path';
import fs from 'fs';

interface Options extends CodeOptions {
  close?: boolean;
  output: string;
}

export function TurbopackCodeInspectorPlugin(options: Options) {
  const record: RecordInfo = {
    port: 0,
    entry: '',
    output: options.output,
  };
  
  return (nextConfig: any = {}) => {
    // Handle if Next.js passes a string (like 'phase-development-server')
    if (typeof nextConfig === 'string') {
      nextConfig = {};
    }
    
    // Check if plugin should be active (similar to vite's apply())
    if (options.close || !isDev(options.dev, process.env.NODE_ENV !== 'production')) {
      // Clean up instrumentation file if it exists
      const instrumentationPath = path.join(process.cwd(), 'instrumentation-client.js');
      if (fs.existsSync(instrumentationPath)) {
        fs.unlinkSync(instrumentationPath);
      }
      return nextConfig;
    }
    
    // Create instrumentation file for Next.js 15.3+ (Turbopack specific requirement)
    // Start server and create instrumentation file
    let serverStartPromise: Promise<void> | null = null;
    if (options.behavior?.locate !== false) {
      serverStartPromise = startServer(options, record).catch(() => {
        // Server start failed, but we'll continue anyway
      });
    }
    
    const createInstrumentationFile = () => {
      // Generate the web component code with the actual port
      const webComponentCode = getWebComponentCode(options, record.port);
      
      const instrumentationCode = `// Auto-generated by code-inspector-plugin
// This file runs before your frontend code starts executing

if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
  // Only run once
  if (!window.__code_inspector_initialized) {
    window.__code_inspector_initialized = true;
    
    ${webComponentCode}
  }
}`;
      
      const projectDir = process.cwd();
      const instrumentationPath = path.join(projectDir, 'instrumentation-client.js');
      
      // Check if file already exists with same content to avoid unnecessary writes
      let shouldWrite = true;
      if (fs.existsSync(instrumentationPath)) {
        const existingContent = fs.readFileSync(instrumentationPath, 'utf-8');
        shouldWrite = existingContent !== instrumentationCode;
      }
      
      if (shouldWrite) {
        fs.writeFileSync(instrumentationPath, instrumentationCode, 'utf-8');
        
        // Add to .gitignore if it exists
        const gitignorePath = path.join(projectDir, '.gitignore');
        if (fs.existsSync(gitignorePath)) {
          const gitignore = fs.readFileSync(gitignorePath, 'utf-8');
          if (!gitignore.includes('instrumentation-client.js')) {
            fs.appendFileSync(gitignorePath, '\n# Auto-generated by code-inspector-plugin\ninstrumentation-client.js\n');
          }
        }
      }
    };
    
    // If server is starting, wait for it; otherwise create file immediately
    if (serverStartPromise) {
      serverStartPromise.then(createInstrumentationFile).catch(() => {
        // Server failed to start, creating instrumentation file anyway
        createInstrumentationFile();
      });
    } else {
      createInstrumentationFile();
    }
    
    // Configure Turbopack rules (Turbopack specific - uses glob patterns as keys)
    nextConfig.turbopack = nextConfig.turbopack || {};
    nextConfig.turbopack.rules = nextConfig.turbopack.rules || {};
    
    // Apply loader to JSX/TSX files
    const loaderOptions = { ...options, record };
    
    // Turbopack requires separate rules for each file extension
    nextConfig.turbopack.rules['**/*.{jsx,tsx}'] = {
      loaders: [{
        loader: 'webpack-code-inspector-plugin/dist/loader.js',
        options: loaderOptions,
      }],
    };
    
    return nextConfig;
  };
}